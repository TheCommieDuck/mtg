==============================================




{-

  format "CREATE TYPE %s AS ENUM ( %s );" name labels

   [ "CREATE TYPE"
  , docLabels 
  , "AS ENUM"
  , " ("
  , docLabels 
  , " );"
  ]

  go
    = PP.align
    . PP.sep
    . List.zipWith (<+>) (List.repeat ", ")

type SQLDoc = PP.Doc SQLAnnotation

data SQLAnnotation

  = SQLKeyword 
  | SQLString 
  | SQLComment 
  | SQLEnumName 
  | SQLEnumLabel 

PP.ANSI.bold
PP.ANSI.italicized
PP.ANSI.underlined

PP.ANSI.colorDull

-- The 8 ANSI terminal colors:

enum Color

Black	 
Red	 
Green	 
Yellow	 
Blue	 
Magenta	 
Cyan	 
White	 




-}



==============================================

annotateKeyword :: String -> SQLDoc
annotateKeyword s = PP.annotate (Just SQLKeyword) (PP.pretty s)

annotateString :: String -> SQLDoc
annotateString s = PP.annotate (Just SQLString) (PP.pretty s)

annotateType :: String -> SQLDoc
annotateType s = PP.annotate (Just SQLType) (PP.pretty s)

annotateComment :: String -> SQLDoc
annotateComment s = PP.annotate (Just SQLComment) (PP.pretty s)

annotateLiteral :: String -> SQLDoc
annotateLiteral s = PP.annotate (Just SQLLiteral) (PP.pretty s)


>>> sql_CREATE_rgb = sql_CREATE_TYPE_AS_ENUM SQLCreateEnum{ enumName = "rgb", enumLabels = [ "r", "g", "b" ] }
>>> sql_CREATE_rgb
CREATE TYPE rgb AS ENUM ('r', 'g', 'b');


PP.SimpleDocStream

(Just PP.defaultLayoutOptions{ = })



>>> sql_CREATE_color layout = sql_CREATE_TYPE_AS_ENUM layout SQLCreateEnum{ enumName = "color", enumLabels = [ "white", "blue", "black", "red", "green" ] }
>>> Prelude.putStrLn (sql_CREATE_color Nothing)
CREATE TYPE color AS ENUM ('white', 'blue', 'black', 'red', 'green');
>>> Prelude.putStrLn (sql_CREATE_color (Just PP.LayoutOptions { PP.layoutPageWidth = PP.AvailablePerLine 30 1.0 }))
CREATE TYPE color AS ENUM ( 'white',
                            'blue',
                            'black',
                            'red',
                            'green' );






extensions = 

    "AutoDeriveTypeable\ 
     BangPatterns\ 
     CPP\ 
     ConstraintKinds\ 
     DataKinds\ 
     DefaultSignatures\ 
     DeriveAnyClass\ 
     DeriveAnyClass\ 
     DeriveDataTypeable\ 
     DeriveDataTypeable\ 
     DeriveFoldable\ 
     DeriveFunctor\ 
     DeriveGeneric\ 
     DeriveGeneric\ 
     DeriveLift\ 
     DeriveTraversable\ 
     DerivingStrategies\
     DerivingStrategies\ 
     DoAndIfThenElse\ 
     DuplicateRecordFields\ 
     EmptyCase\ 
     EmptyDataDecls\ 
     ExplicitNamespaces\ 
     FlexibleContexts\ 
     FlexibleContexts\ 
     FlexibleInstances\ 
     FlexibleInstances\ 
     FunctionalDependencies\ 
     GADTs\ 
     GeneralizedNewtypeDeriving\ 
     InstanceSigs\ 
     KindSignatures\ 
     KindSignatures\ 
     LambdaCase\ 
     LambdaCase\ 
     MultiParamTypeClasses\ 
     MultiWayIf\ 
     NamedFieldPuns\ 
     NoImplicitPrelude\ 
     NoImplicitPrelude\ 
     PackageImports\ 
     PackageImports\ 
     PatternSynonyms\ 
     PostfixOperators\ 
     RankNTypes\ 
     RecordWildCards\ 
     ScopedTypeVariables \ 
     ScopedTypeVariables\ 
     StandaloneDeriving\ 
     TupleSections\ 
     TupleSections\ 
     TypeFamilies\ 
     TypeFamilies\ 
     TypeOperators\ 
     TypeOperators\ 
     UndecidableInstances\ 
     ViewPatterns"











--------------------------------------------------

extensions2flags :: [String] -> [String]
extensions2flags = fmap go . filterBlanks
  where

  go s = if (not (null s)) then ("-X" ++ s) else










>>> sql_CREATE_color layout = sql_CREATE_TYPE_AS_ENUM layout SQLCreateEnum{ enumName = "color", enumLabels = [ "white", "blue", "black", "red", "green" ] }
>>> Prelude.putStrLn (sql_CREATE_color Nothing)
CREATE TYPE color AS ENUM ( 'white', 'blue', 'black', 'red', 'green' );
>>> Prelude.putStrLn (sql_CREATE_color (Just PP.LayoutOptions { PP.layoutPageWidth = PP.AvailablePerLine 30 1.0 }))
CREATE TYPE color AS ENUM ( 'white',
                            'blue',
                            'black',
                            'red',
                            'green' );









data CardObject = CardObject 
 
  { _id            :: Text 
  , _layout        :: Text 
  , _name          :: Text 
  , _names         :: Maybe [Text] 
  , _manaCost      :: Maybe Text 
  , _cmc           :: Natural 
  , _colors        :: Maybe [Text] 
  , _colorIdentity :: Maybe [Text] 
  , _type          :: Text 
  , _supertypes    :: Maybe [Text] 
  , _types         :: Maybe [Text] -- ^ Un-cards can have no type 
  , _subtypes      :: Maybe [Text] 
  , _rarity        :: Text 
  , _text          :: Maybe Text 
  , _flavor        :: Maybe Text 
  , _artist        :: Text
  , _number        :: Maybe Text
  , _power         :: Maybe Text -- ^ Un-cards can have non-integer power/toughness 
  , _toughness     :: Maybe Text  
  , _loyalty       :: Maybe Natural 
  , _multiverseid  :: Maybe Natural
  , _variations    :: Maybe [Natural] 
  , _imageName     :: Maybe Text 
  , _watermark     :: Maybe Text 
  , _border        :: Maybe Text 
  , _timeshifted   :: Maybe Bool -- IsCardTimeShifted
  , _hand          :: Maybe Integer  -- ^ Vanguard only 
  , _life          :: Maybe Integer -- ^ Vanguard only 
  , _reserved      :: Maybe Bool -- IsCardReserved 
  , _releaseDate   :: Maybe Text -- ^ Promo only 
  , _starter       :: Maybe Bool -- IsCardStarter 
  , _mciNumber     :: Maybe Text  -- ^ used by `MagicCards.info`, almost always identical to '_CardObject_number' 
  , _rulings       :: Maybe [CardRulingObject] 
  , _foreignNames  :: Maybe [CardForeignPrintingObject] 
  , _printings     :: [Text]  
  , _originalText  :: Maybe Text 
  , _originalType  :: Maybe Text
  , _legalities    :: Maybe [CardFormatLegalityObject]
  , _source        :: Maybe Text 

  }















  , _artist                 :: -- ^ e.g. @"..."@
  , _borderColor            :: -- ^ e.g. @"black"@
  , _colorIdentity          :: -- ^ e.g. @[ ... ]@
  , _colors                 :: -- ^ e.g. @[ ... ]@
  , _convertedManaCost      :: -- ^ e.g. @0@
  , _foreignData            :: -- ^ e.g. @[ ... ]@
  , _frameVersion           :: -- ^ e.g. @YYYY@
  , _hasFoil                :: -- ^ e.g. @"false"@
  , _hasNonFoil             :: -- ^ e.g. @"true"@
  , _isReserved             :: -- ^ e.g. @"true"@
  , _layout                 :: -- ^ e.g. @"normal"@
  , _legalities             :: -- ^ e.g. @{ "vintage": "restricted", "legacy": "banned", "standard": "legal", ... }@
  , _manaCost               :: -- ^ e.g. @"{B}{B/2}{B/P}"@
  , _multiverseId           :: -- ^ e.g. @390@
  , _name                   :: -- ^ e.g. @"Phyrexian Goblin"@
  , _number                 :: -- ^ e.g. @"51a"@ (@Delver of Secrets@, being a /Double-Faced Card/, has an alphanumeric @collectersNumber@; @Insectile Aberration@'s is @"51b"@).
  , _originalText           :: -- ^ e.g. @"..."@
  , _originalType           :: -- ^ e.g. @"Summon Legend"@
  , _printings              :: -- ^ e.g. @[ "LEA", "LEB" ]@
  , _rarity                 :: -- ^ e.g. @"common"@
  , _rulings                :: -- ^ e.g. @[ ... ]@
  , _scryfallId             :: -- ^ e.g. @"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"@
  , _scryfallIllustrationId :: -- ^ e.g. @"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"@
  , _scryfallOracleId       :: -- ^ e.g. @"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"@
  , _subtypes               :: -- ^ e.g. @[ "Goblin", "Wizard" ]@
  , _supertypes             :: -- ^ e.g. @[ "Legendary", "Snow" ]@
  , _text                   :: -- ^ e.g. @"..."@
  , _type                   :: -- ^ e.g. @"Legendary Snow Artifact Creature — Goblin Construct"@
  , _types                  :: -- ^ e.g. @[ "Artifact", "Creature" ]@
  , _uuid                   :: -- ^ e.g. @"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"@
  , _uuidV421               :: -- ^ e.g. @"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"@
  }





















instance IsList Colors where
  type Item Colors = String
  fromList = coerce . fmap T.pack
  toList   = fmap T.unpack . coerce














--------------------------------------------------
-- Pretty ----------------------------------------
--------------------------------------------------

instance Pretty UUID where

  pretty = prettyUUID





















flags :: [String]
flags = concat

  [ [ ":set -package mtg-types" ]
  , extensions2flags extensions
  , options
  ]



















newtype ManaCost = ManaCost Text
 
  deriving stock    (Show,Read)
  deriving stock    (Lift,Data,Generic)

  deriving newtype  (Eq,Ord,Semigroup,Monoid)
  deriving newtype  (IsString)
  deriving newtype  (NFData,Hashable)













-- | @≡ "Colorless"@

pattern Colorless :: Color
pattern Colorless = "Colorless"

colorless :: Color
colorless = "Colorless"


abbreviateColor :: Color -> Maybe Text
abbreviateColor (Color s0) = Text.toUpper <$> (go s1)
  where

  s1 = Text.toLower s0

  go = \case

    "white"     -> Just "W"
    "blue"      -> Just "U"
    "black"     -> Just "B"
    "red"       -> Just "R"
    "green"     -> Just "G"
    "colorless" -> Just "C"

    "w"         -> Just "W"
    "u"         -> Just "U"
    "b"         -> Just "B"
    "r"         -> Just "R"
    "g"         -> Just "G"
    "c"         -> Just "C"

    _           -> Nothing









module MTG.Types.Parse

  ( module MTG.Types.Parse

  , Parsing(..)
  , CharParsing(..)
  ) where



==============================================


--------------------------------------------------
-- Constants -------------------------------------
--------------------------------------------------

white :: Color
white = "White"

blue :: Color
blue = "Blue"

black :: Color
black = "Black"

red :: Color
red = "Red"

green :: Color
green = "Green"







>>> parse "U" == Blue
True
>>> parse "blue" == Blue
True





pAssoc :: (CharParsing m) => Assoc a -> m a
pAssoc kvs = asum (pPair <$> kvs)
  where

  pPair (k,v) = P. _











-- | Association List.

type Assoc a = [( Text, a )]








pColor :: CharParsing m => m Color
pColor = do

  pAssoc cs

  where

  cs :: Assoc Color
  cs = csLower <> csUpper

  csLower = csUpper & bimap Text.toLower id

  csUpper =

    [ "W" -: White
    , "U" -: Blue
    , "B" -: Black
    , "R" -: Red
    , "G" -: Green

    , "White" -: White
    , "Blue"  -: Blue
    , "Black" -: Black
    , "Red"   -: Red
    , "Green" -: Green
    ]









data Annotation

  = AnnOracleText
  | AnnReminderText
  | AnnFlavorText

  | AnnWhite
  | AnnBlue
  | AnnBlack
  | AnnRed
  | AnnGreen
  | AnnColorless

  | AnnKeyword
  | AnnPerson
  | AnnNamesake

  | AnnUnicode Char
















{-| Pretty-Print an @Enum@ via an /association list/.

-}

ppAssoc
  :: Assoc a
  -> (a -> Maybe (Doc i))

ppAssoc kvs = \x ->

  let
    doc' = Map.lookup v kvs'
    doc  = PP.pretty <$> doc'
  in
    doc

  where

  ppKVs = _

  kvs' :: Map a Text
  kvs' = kvs & 

  (foldr (<|>) empty) pKvs

{-# INLINEABLE ppAssoc #-}













runParser :: forall a. (forall m. (MTGParsing m) => m a) -> (String -> [a])
runParser p = go
  where

  go :: String -> [a]
  go = Read.readP_to_S p > fmap fst

















runParser :: (MonadThrow m) => forall a. (forall m. (MTGParsing p) => p a) -> (String -> m a)
runParser p = go
  where

  go :: String -> m a
  go =

    let
      p' :: ReadP a
      p' = p
    in
      Read.readP_to_S p' > fmap fst > throwListM

-- readP_to_S :: ReadP a -> ReadS a
-- readP_to_S :: ReadP a -> String -> [(a,String)]















data ParseError = ParseError

  { getParseErrors :: [String]
  }













renderText :: PP.SimpleDocStream i -> Text
renderText = PP.layoutSmart PP.defaultLayoutOptions > PP.Text.renderStrict











>>> "prefix" <+> align (vsep ["text", "to", "lay", "out"])
prefix text
       to
       lay
       out







data ParseError = ParseError

  { getParseErrors :: [MTGDocument]
  }

  deriving stock    (Generic)
  deriving stock    (Eq,Ord)
  deriving anyclass (Semigroup,Monoid)
  deriving anyclass (NFData,Hashable)











{-| 

== Signatures

@
'ParseError' :: ['MTGDocument'] -> 'ParseError'
'parseError' :: String   ->   'SomeException'
@

-}

parseError :: String -> SomeException
parseError

  = pretty
  > (: [])
  > ParseError
  > toException












--------------------------------------------------

{-| Multiple errors

== Signatures

@
'ParseError' :: ['MTGDocument'] -> 'ParseError'
'parseErrors' :: [String]     -> 'ParseError'
@

-}

parseErrors :: [String] -> ParseError
parseErrors

  = fmap pretty
  > ParseError










runParser
  :: forall m a.
     ( MonadThrow m
     )
  => String -> (forall p. (MTGParsing p) => p a)
  -> (String -> m a)

runParser e p = go
  where

  go :: String -> m a
  go =

    let
      p' :: ReadP a
      p' = p
    in
      Read.readP_to_S p' > fmap fst > throwListM (parseError e)







{- | 

@
instance 'IsString' XYZ where
  fromString = 'fromString_MonadThrow' parseXYZ
@

-}

fromString_MonadThrow
  :: forall a.
     (forall m. (MonadThrow m) => String -> m a)
  -> (String -> a)
fromString_MonadThrow pM = pI
  where

  pI = pM










import           "base" GHC.Stack.Types (HasCallStack)
import           "base" GHC.Stack       (CallStack,callStack,prettyCallStack)--,getCallStack










instance ( HasCallStack ) => IsString Color where










pManaSymbol :: (MTGParsing m) => m ManaSymbol
pManaSymbol = P.braces (pAbbreviatedManaSymbol `P.sepBy1` P.spaces)

--------------------------------------------------

pAbbreviatedManaSymbol :: (MTGParsing m) => m ManaSymbol
pAbbreviatedManaSymbol = _










prettyManaSymbol :: ManaSymbol -> String
prettyManaSymbol (ManaSymbol cs) = ppManaSymbol > runPrinter










pManaSymbol :: (MTGParsing m) => m ManaSymbol
pManaSymbol = toManaSymbol (P.braces pAbbreviatedManaSymbol) `P.sepBy1` P.spaces









pManaSymbol :: (MTGParsing m) => m ManaSymbol
pManaSymbol = pAbbreviatedManaSymbol -- TODO pKnown pUnknown

--------------------------------------------------

pAbbreviatedManaSymbol :: (MTGParsing m) => m ManaSymbol
pAbbreviatedManaSymbol = ManaSymbol <$> P.braces p
  where

  p = empty









abbreviateManaSymbol :: ManaSymbol -> Maybe Text
abbreviateManaSymbol (ManaSymbol s0) = Text.toUpper <$> (go s1)
  where

  s1 = Text.toLower s0

  go = \case

    "white"     -> Just "W"
    "blue"      -> Just "U"
    "black"     -> Just "B"
    "red"       -> Just "R"
    "green"     -> Just "G"

    "w"         -> Just "W"
    "u"         -> Just "U"
    "b"         -> Just "B"
    "r"         -> Just "R"
    "g"         -> Just "G"

    _           -> Nothing









abbreviationsManaSymbol :: Assoc ManaSymbol
abbreviationsManaSymbol =

    [ "W" -: WhiteManaSymbol
    , "U" -: BlueManaSymbol
    , "B" -: BlackManaSymbol
    , "R" -: RedManaSymbol
    , "G" -: GreenManaSymbol
    ]








abbreviatedManaSymbols :: Assoc ManaSymbol
abbreviatedManaSymbols =

    [ "W" -: WhiteManaSymbol
    , "U" -: BlueManaSymbol
    , "B" -: BlackManaSymbol
    , "R" -: RedManaSymbol
    , "G" -: GreenManaSymbol
    ]








------------------

phyrexian :: ManaSymbol -> ManaSymbol
phyrexian (ManaSymbol s) = ManaSymbol ("{P" <> s <> "}")

--------------------------------------------------

monohybrid :: ManaSymbol -> ManaSymbol
monohybrid (ManaSymbol s) = ManaSymbol ("{2/" <> s <> "}")








type Colors = [Color]
















whichColors :: [Color] -> Colors
whichColors = _










  e :: PatternMatchFail
  e = PatternMatchFail (format "toColors: {{{ toColors " % Format.string % " }}} " (show cs))













toColorsM :: (MonadThrow m) => [Color] -> m Colors
toColorsM cs = cs & (ordNub > sort > go)
  where

  go = \case

      []                                 -> return (ZeroColors                          )
      [a]                                -> return (OneColor                    a       )
      [a,b]                              -> return (TwoColors   (toGuild        a b)    )
      [a,b,c]                            -> return (ThreeColors (toShardOrWedge a b c)  )
      [a,b,c,d]                          -> return (FourColors  (toNephilim     a b c d))
      [ White, Blue, Black, Red, Green ] -> return (FiveColors                          )
      _                                  -> throwM e -- (NOTE: this case should never be reached.)

  e :: PatternMatchFail
  e = PatternMatchFail (runFormat ("``` " % Format.string % " ```: {{{ toColors " % Format.string % " }}} ")
                        (displayName 'toColors)
                        (showsPrec applicationPrecedence cs "")
                       )





















toGuild :: (MonadThrow m) => Color -> Color -> m Guild

toGuild White Blue  = return Azorius  
toGuild Blue  White = return Azorius  

toGuild Blue  Black = return Dimir    
toGuild Black Blue  = return Dimir    

toGuild Black Red   = return Rakdos   
toGuild Red   Black = return Rakdos   

toGuild Red   Green = return Gruul    
toGuild Green Red   = return Gruul    

toGuild Green White = return Selesnya 
toGuild White Green = return Selesnya 

toGuild White Black = return Orzhov
toGuild Black White = return Orzhov

toGuild Black Green = return Golgari  
toGuild Green Black = return Golgari  

toGuild Green Blue  = return Simic    
toGuild Blue  Green = return Simic    

toGuild Blue  Red   = return Izzet    
toGuild Red   Blue  = return Izzet    

toGuild Red   White = return Boros    
toGuild White Red   = return Boros

toGuild White White = throwM e
toGuild Blue  Blue  = throwM e
toGuild Black Black = throwM e
toGuild Red   Red   = throwM e
toGuild Green Green = throwM e





















toNephilim White Blue Black Red = return Artifice
toNephilim Black Red Green Blue = return Chaos
toNephilim Red Green White Black = return Aggression
toNephilim Green White Blue Red = return Altruism
toNephilim White Blue Black Green = return Growth



toNephilim :: (MonadThrow m) => Color -> Color -> Color -> Color -> m Nephilim

toNephilim White Blue  Black Red   = return Artifice
toNephilim White Black Red   Blue  = return Artifice
toNephilim White Red   Blue  Black = return Artifice
toNephilim White Blue  Red   Black = return Artifice
toNephilim White Black Blue  Red   = return Artifice
toNephilim White Red   Black Blue  = return Artifice




toNephilim w x y z = case sort [ w, x, y, z ] of

   ArtificeColors -> return Artifice
   ChaosColors -> return Chaos
   AggressionColors -> return Aggression
   AltruismColors -> return Altruism
   GrowthColors -> return Growth











toColorsM :: (MonadThrow m) => [Color] -> m Colors
toColorsM cs = cs & (ordNub > sort > go)
  where

  go = \case

      []                                 -> return ZeroColors
      [a]                                -> return $ OneColor a
      [a,b]                              -> TwoColors   <$> (toGuild        a b)
      [a,b,c]                            -> ThreeColors <$> (toShardOrWedge a b c)
      [a,b,c,d]                          -> FourColors  <$> (toNephilim     a b c d)
      [ White, Blue, Black, Red, Green ] -> return FiveColors

      _                                  -> throwM e -- (NOTE: this case should never be reached.)

  e :: PatternMatchFail
  e = PatternMatchFail (runFormat ("``` " % Format.string % " ```: {{{ toColors " % Format.string % " }}} ")
                        (displayName 'toColors)
                        (showsPrec applicationPrecedence cs "")
                       )












>>> sortColors AzoriusColors
[White,Blue]
>>> sortColors SelesnyaColors
[Green,White]










sortColors :: [Color] -> [Color]
sortColors colorsList = sortedColors
  
  where

  sortedColors = colorsSet & maybe colorsList toColors
  colorsSet    = toColorsM colorsList










prettySymbol :: Symbol -> Doc i
prettySymbol symbol = PP.braces docSymbol
  where

  docSymbol    = PP.pretty stringSymbol
  stringSymbol = getSymbolText symbol









mainParser  = sum <$ whiteSpace <*> many (token digit) <* eof
runParserCompletely name p = runParserPartially name q
  where

  q = (p <* P.eof)
















{-| Parse a symbol token.

== Examples

>>> runParser 'pSymbol pSymbol "{αàéñ①∞∅↑•✔✘❓}"

-}

pSymbol
  :: forall m.
     ( TokenParsing m
     )
  => m a
  -> m a

pSymbol p = P.braces p







pTextChar
  :: forall m.
     ( TokenParsing m
     )
  => m Char

pTextChar = P.satisfy predicate
  where

  predicate c
    = Char.isPrint c
   && not (Char.isSpace c)
   && not (Char.isPunctuation c)
   && not (isQuote c)

  isQuote c
    = c == '"'
   || c == '\''















pManaSymbol :: (MTGParsing m) => m ManaSymbol
pManaSymbol = do

  pAssoc cs

  where

  cs :: Assoc ManaSymbol
  cs = csLower <> csUpper

  csLower = csUpper <&> (bimap Text.toLower id)

  csUpper = namedManaSymbols










 keywordLet  = try $ string "let" <* notFollowedBy alphaNum













 simpleComment   = do{ string "<!--"
                     ; manyTill anyChar (try (string "-->"))
                     }













--------------------------------------------------

{-| Parse any (printable) text except the given text.

i.e. @pFreeTextExcept p@ parses:

* yes printable.
* not @p@

See 'pFreeTextChar'.

== Examples

>>> runParser 'pFreeTextExcept (pFreeTextExcept (P.char ' ')) "free text")
>>> runParser 'pFreeTextExcept (pFreeTextExcept empty) "free text")
"free text"

-}

pFreeTextExcept
  :: forall m.
     ( TokenParsing m
     )
  => m Text
  -> m Text

pFreeTextExcept p = Text.pack <$> q
  where

  q = pFreeTextChar `P.manyTill` (P.try p) 










pFreeTextExcept
  :: forall m.
     ( TokenParsing m
     )
  => [Char]
  -> m Text

pFreeTextExcept "" = Text.pack <$> pFreeTextChar

pFreeTextExcept cs = Text.pack <$> q
  where

  q = pFreeTextChar `P.manyTill` P.try pNotChar

  pNotChar = P.noneOf cs








oneOfSet (CharSet True _ is)  = satisfy (\c -> IntSet.member (fromEnum c) is)
oneOfSet (CharSet False _ is) = satisfy (\c -> not (IntSet.member (fromEnum c) is))









--------------------------------------------------

pLanguageEndonym :: (MTGParsing m) => m Text
pLanguageEndonym = pUnfreeText pOpenParen
  where

  pOpenParen = P.char '('












pLanguageInfo :: (MTGParsing m) => m LanguageInfo
pLanguageInfo = p <?> "LanguageInfo"
  where

  p = do

      endonym <- pLanguageEndonym
      P.spaces
      abbreviation <- P.parens pLanguageAbbreviation

      pure LanguageInfo{..}

------------------------------------













addCMCs :: CMC -> CMC -> CMC 
addCMCs = coerce (+)









-- | @= 'cmcAdd'@
instance Semigroup CMC where (<>)   = cmcAdd

-- | @= 0@
instance Monoid    CMC where mempty = coerce (0 :: Natural)

--------------------------------------------------

-- | @= 'defaultCMC'@
instance Default CMC where def = defaultCMC

--------------------------------------------------
-- Patterns --------------------------------------
--------------------------------------------------

pattern ZeroCMC :: CMC
pattern ZeroCMC = CMC 0















\917\955\955\951\957\953\954\940












sortColors :: [Color] -> [Color]
sortColors

  = fmap getColor
  > fmap isColorKnown
  > partitionEithers
  > go

  where

  go ( unknownColors, knownColors )
    = sortKnownColors knownColors
   ++ sortUnknownColors unknownColors

  sortKnownColors :: [Color.Color] -> [Color]
  sortKnownColors
    = Color.sortMTGColors
    > fmap show
    > fmap Color

  sortUnknownColors :: [Color] -> [Color]
  sortUnknownColors = sort





isColorKnown :: Color -> Either Text Color.Color
isColorKnown (Color t) = Left t











== Examples

>>> :set -XOverloadedStrings
>>> pretty (languageInfo "Russian" :: Maybe LanguageInfo) == "Русский (ru)"
True
>>> pretty (languageInfo "Greek" :: Maybe LanguageInfo) == ""
True








>>> :set -XOverloadedStrings
>>> Just "Русский (ru)" <- pretty (languageInfo "Russian" :: Maybe LanguageInfo)
>>> Nothing <- (languageInfo "Greek" :: Maybe LanguageInfo)









{-| 

== Examples

Printing...

>>> pretty (ManaSymbol "U")
{U}
>>> pretty (colorToManaSymbol Blue)
{U}

Parsing...

>>> parseManaSymbol "{U}"
ManaSymbol "U"
>>> parseManaSymbol "{1}"
ManaSymbol "1"

>>> parseManaSymbol "{G/U}"
ManaSymbol "G/U"
>>> parseManaSymbol "{U/R}"
ManaSymbol "G/U"

>>> parseManaSymbol "{P/U}"

>>> parseManaSymbol "{2/U}"

-}
















toColors :: [Color] -> Colors
toColors unsortedColors = Colors sortedColors
  where

  sortedColors = sortColors uniqueColors --TODO
  uniqueColors = ordNub unsortedColors














isColorKnown :: Color -> Either Text Color.Color
isColorKnown (Color t) = Left t

{-# INLINEABLE isColorKnown #-}









>>> :set -XOverloadedStrings
>>> Prelude.putStrLn (Prelude.show ("unparseable" :: ParseError))
[ParseError] Can't parse <<< "unparseable" >>>.




>>> toColors Simic == toColors (reverse Simic)
True






:set -XTemplateHaskellQuotes
import qualified "parsers" Text.Parser.Combinators as P
import qualified "parsers" Text.Parser.Char as P
import qualified "parsers" Text.Parser.Token as P
runParserPartially anonymous (pLanguageEndonym *> P.symbolic '(' *> pFreeText *> P.eof) "words before ( words after"

"words before"









































cli :: IO ()
cli = do
  nothing




















    helpVersion :: String
    helpVersion = "Print the version of this program. The format is: dot-separated numerics. For example: {{{ 0.11.0 }}}. When the verbosity is {{{ 1 }}} (the default) or less, no other text is printed (also see option {{{ --verbose }}}); when {{{ 2 }}} or greater, also print the patch version (i.e. the git commit) and build information (the compiler version, and transitive dependencies' versions)."

    helpLicense :: String
    helpLicense = "Print the license of this program. The format is: an SPDX License Identifier (alphanumerics, plus hyphens and/or dots). For example: {{{ Apache-2.0 }}}. When the verbosity is {{{ 1 }}} (the default) or less, no other text is printed (also see option {{{ --verbose }}}); when {{{ 2 }}} or greater, also print the license contents."












import Options.Applicative
import Options.Applicative.Help as AH
import Options.Applicative.Types as AT
import System.Environment (getArgs, getProgName)
import System.Exit (exitWith, ExitCode(..))
import System.IO (hPutStr, stderr)

execParserWithHelp :: ParserPrefs -> ParserInfo a -> IO a
execParserWithHelp pprefs pinfo = do
  args <- getArgs
  case execParserPure pprefs pinfo args of
    Right a -> return a
    Left failure -> do
      progn <- getProgName
      msg <- AT.errMessage failure progn
      let extra = if null args
                  then AH.parserHelpText pprefs pinfo
                  else ""
      let c = errExitCode failure
      case c of
        ExitSuccess -> putStr (msg ++ extra)
        _           -> hPutStr stderr (msg ++ extra)
      exitWith c

main :: IO ()
main = execParserWithHelp (prefs idm) opts >>= run

opts :: ParserInfo Command
opts = info (commands <**> helper) idm

run :: Command -> IO ()
run = ...


























{-| -}

fromParserResult :: P.ParserResult a -> Either SomeException a
fromParserResult = \case

    P.Success a           -> Right a
    P.Failure e           -> Left (toStdErrException (P.renderFailure e programExecutable))
    P.CompletionInvoked _ -> Left def

  where

    toStdErrException :: (String, ExitCode) -> SomeException
    toStdErrException (stderr, exitcode) = toException (Prelude.userError s)
      where

        s :: String
        s = runFormat ("Exit Code: " % Format.int % "\n\
                        Std Err:\n" % Format.string)
            exitcode
            stderr

{-# INLINEABLE fromParserResult #-}














import qualified GHC.Exception ( errorCallWithCallStackException )
















negateMtgNumber :: MtgNumber -> MtgNumber
negateMtgNumber = normalizeMtgNumber . go
  where

  go :: MtgNumber -> MtgNumber
  go = \case

    MtgWildcard -> 0 - MtgWildcard
    MtgNatural n -> 0 - MtgNatural n
    MtgAdd x y -> MtgAdd x y
    MtgMinus x y -> MtgMinus x y






data Operation
 = Addition
 | Subtraction

data Literal
  = Natural Natural
  | Wildcard


data MTGNumber

  = 


data NOperation
 = NAddition
 | NSubtraction

data NLiteral
  = NNatural Natural
  | NWildcard




{- | `fromInteger` is `MtgNatural`.

>>> (0 :: MtgNumber)
>>> 'MtgNatural' 0
-}

instance Num MtgNumber where

      fromInteger = MtgNatural . fromInteger
      (+)         = MtgAdd
      (*)         = 
     
      negate      = fmap negate
      abs         = fmap abs
      signum      = fmap signum
























{-# SPECIALIZE putAnsiDocs :: PP.Chunk (PP.Doc) -> IO () #-}
























pPrint :: P.Parser Subcommand
pPrint = asum

  [ P.strArgument "version" PrintVersion
  , P.strArgument "license" PrintLicense
  ]
















pFetch :: P.Parser Subcommand
pFetch = do

  src' <- pSrc
  dst' <- pDst

  let src = src'
  let dst = dst'
  let srcdst = SrcDst{ src, dst }

  return (FetchJSON srcdst)

  where

  pSrc :: P.Parser Src
  pSrc = _

  pDst :: P.Parser Dst
  pDst = _












  dryrun <- (P.flag TrueRun DryRun) (mconcat

        [ P.long    "dryrun"
        , P.short   'i'
        , P.style   P.bold
        , P.help    "Disable effects. Whether the execution will just be a 'dry-run' (i.e. most effects are disabled, instead they are printed out). {{{ -i }}} abbreviates \"information\"."
        ])


{{{ -p }}} abbreviates \"print\"."

{{{ -z }}} abbreviates \"zero effects\"."





















data SrcDst = SrcDst

  { src :: Maybe Src
  , dst :: Maybe Dst
  }















pFetch :: P.Parser Subcommand
pFetch = do

  src <- pSrc
  dst <- pDst

  let srcdst = SrcDst{ src, dst }

  return (FetchJSON srcdst)












{- |

== CLI

* `Quiet`   — @$ mtg-json -v0 ...@ or @$ mtg-json -q ...@ (a.k.a. the default).
* `Concise` — @$ mtg-json -v ...@ or @$ mtg-json ...@ (a.k.a. the default).
* `Verbose` — @$ mtg-json -v1 ...@ or @$ mtg-json -v ...@
* `Loud`    — @$ mtg-json -v2 ...@ or @$ mtg-json -vv ...@

-}

data Verbosity

  = Quiet
  | Concise
  | Verbose
  | Loud


















#------------------------------------------------#

mtg-scryfall:

	$(CabalBuild) -f"+develop" "lib:mtg-scryfall"

.PHONY: mtg-scryfall













pFetch :: P.Parser Subcommand
pFetch = FetchJSON <$> do

  src <- pSrc
  dst <- pDst

  return SrcDst{ src, dst }

  where

  pSrc :: P.Parser Src
  pSrc = parseSrc <$> (P.option P.str) (mconcat

        [ P.long    "input"
        , P.short   'i'
        , P.metavar "URI"
        , P.value   defaultSrc
        , P.showDefault
        , P.style   P.bold
        , P.help    "Where to input the {{{ mtg.json }}} JSON file from."
        ])

  pDst :: P.Parser Dst
  pDst = parseDst <$> (P.option P.str) (mconcat

        [ P.long    "output"
        , P.short   'o'
        , P.metavar "FILE"
        , P.value   defaultDst
        , P.showDefault
        , P.style   P.bold
        , P.help    "Where to output the parsed {{{ mtg.hs }}} Haskell file into (readable via the {{{ Read }}} typeclass)."
        ])

  fields :: P.Mod P.ArgumentFields a
  fields = mconcat
    [ P.completeWith cPrint
    ]

  rSrc :: P.ReadM Subcommand
  cSrc :: [String]
  (rSrc, cSrc) = pAssoc knownSources

  defaultSrc :: String
  defaultSrc = SrcUri defaultSource

  defaultDst :: String
  defaultDst = DstFile defaultDestination

  knownSrcs :: [Src]
  knownSrcs = SrcUri <$> (fst <$> knownSources)





























  where

  ------------------------------

  pSrc :: P.Parser Src
  pSrc = parseSrc <$> (P.option P.str) (mconcat

        [ P.long    "input"
        , P.short   'i'
        , P.metavar "URI"
        , P.value   defaultSrc
        , P.showDefault
        , P.completeWith cSrc
        , P.style   P.bold
        , P.help    "Where to input the {{{ mtg.json }}} JSON file from."
        ])

  pDst :: P.Parser Dst
  pDst = parseDst <$> (P.option P.str) (mconcat

        [ P.long    "output"
        , P.short   'o'
        , P.metavar "FILE"
        , P.value   defaultDst
        , P.showDefault
        , P.completeWith cDst
        , P.style   P.bold
        , P.help    "Where to output the parsed {{{ mtg.hs }}} Haskell file into (readable via the {{{ Read }}} typeclass)."
        ])

  ------------------------------

  defaultSrc :: String
  defaultSrc = SrcUri defaultSource

  defaultDst :: String
  defaultDst = DstFile defaultDestination

  ------------------------------

  rSrc :: P.ReadM Src
  cSrc :: [String]

  (rSrc, cSrc) = pAssoc (SrcUri <$> (fst <$> knownSources))

  rDst :: P.ReadM Dst
  cDst :: [String]

  (rDst, cDst) = pAssoc (DstFile <$> (fst <$> knownDestinations))

  ------------------------------

























  go :: Src -> Dst -> IO ()
  go src dst = do

    print (srcToMessage src)
    print (dstToMessage dst)

    writeDst dst

    where

    srcToMessage :: Src -> String
    srcToMessage = \case
      runFormat ("Fetching from: " % Format.string % "...\n") s

    dstToMessage :: Dst -> String
    dstToMessage = \case
      runFormat ("Saving to: " % Format.string % "...\n") s
























  go :: Src -> Dst -> IO ()
  go src = \case

        -- be « --quiet » (i.e. don't print) when saving to stdout.
        --TODO-- or print to stderr??

    DstStdout -> do

        printDst

    DstFile fp -> do

        print (srcToMessage src)
        print (dstToMessage dst)

        writeDst fp

    where

    srcToMessage :: Src -> String
    srcToMessage = \case
      runFormat ("Fetching from: " % Format.string % "...\n") s

    dstToMessage :: Dst -> String
    dstToMessage = \case
      runFormat ("Saving to: " % Format.string % "...\n") s
























fetchJSON :: Options -> SrcDst -> IO ()
fetchJSON Options{..} = \SrcDst{src,dst} -> do

  go src dst

  where

  ------------------------------

  go :: Src -> Dst -> IO ()
  go src dst = do

    putStdErr sSrc
    putStdErr sDst

    case dst of

        DstStdout -> do

            printDst

        DstFile fp -> do

            writeDst fp

      where

      sSrc :: String
      sSrc = runFormat ("\nFetching from: " % Format.string % "...\n") s

      sDst :: String
      sDst = runFormat ("\nSaving to: " % Format.string % "...\n") s



















--------------------------------------------------
-- Functions -------------------------------------
--------------------------------------------------

prettySrc :: Src -> String
prettySrc = \case

  SrcStdin   -> "-"
  SrcFile fp -> "" <> fp
  SrcUri uri -> "" <> uri

--------------------------------------------------

prettyDst :: Dst -> String
prettyDst = \case

  DstStdout  -> "-"
  DstFile fp -> "" <> fp

















  defaultSrc :: Src
  defaultSrc = SrcUri defaultSource

  defaultDst :: Dst
  defaultDst = DstFile defaultDestination




















https://github.com/phadej/cabal-doctest/blob/master/README.md


-- cabal-doctest









When you build your project, this Setup will generate a Build_doctests module. To use it in a testsuite, simply do this:

module Main where

import Build_doctests (flags, pkgs, module_sources)
import Data.Foldable (traverse_)
import Test.DocTest (doctest)

main :: IO ()
main = do
    traverse_ putStrLn args -- optionally print arguments
    doctest args
  where
    args = flags ++ pkgs ++ module_sources





x-doctest-components: lib exe:mtg-json


module Main where

import Build_doctests (Component (..), components)
import Data.Foldable (for_)
import Test.DocTest (doctest)

main :: IO ()
main = for_ components $ \(Component name flags pkgs sources) -> do
    print name
    putStrLn "----------------------------------------"
    let args = flags ++ pkgs ++ sources
    for_ args putStrLn
    doctest args




test-suite doctests:
  if impl(ghc >= 8.0)
    x-doctest-options: -fdiagnostics-color=never
  x-doctest-source-dirs: test
  x-doctest-modules: Servant.Utils.LinksSpec

 
















 ,  "-i" <> "../mtg-types/library"


















optionsLib :: [String]
optionsLib =

  [ "-fdefer-type-errors"
  ,  "-i" <> "../mtg-types/library"
  ,  "-i" <> "./mtg-types/library"
  ]






















>>> tBools = [ "off"-: False, "0"-: False, "on"-: True, "1"-: True ]
>>> ( rBool, _ ) = pAssoc tBools
>>> import qualified Options.Applicative as P
>>> readBool t = P.getParseResult (P.execParserPure P.defaultPrefs (P.info mempty (P.argument mempty rBool)) [t])
>>> readBool "on"















tBools = [ "off"-: False, "0"-: False, "on"-: True, "1"-: True ]
( rBool, _ ) = pAssoc tBools
import qualified Options.Applicative as P
readBool t = P.getParseResult (P.execParserPure P.defaultPrefs (P.info mempty (P.argument mempty rBool)) [t])
readBool "on"













fetchWith :: forall a. HTTPS.Manager -> FetchConfig a -> IO (MTGJSON a)


























  go :: forall x. FetchConfig x -> IO x
  go = \case

    FetchMtgJsonGz uri -> fetchMtgJsonGz uri

  fetchMtgJsonGz :: URI -> IO (MTGJSON a)
  fetchMtgJsonGz uri = do








go = do
  downloadImageFromMagicCardsInfo manager c >>= either failure (success c) 
  failure e = print e 
  success c i = do 
    B.writeFile (pathFromMCICardIdentifier c) i
    delayMilliseconds (t&fromIntegral)  -- threadDelay (fromIntegral t) 

    
downloadImageFromMagicCardsInfo :: Manager -> MCICardIdentifier -> IO (Either HttpException B.ByteString)
downloadImageFromMagicCardsInfo manager c = handleHttpErrors $ do 
  request <- parseUrlThrow url
  response <- httpLbs request manager
  let body = response&responseBody 
  return $ Right body 
  where 
  url = urlFromMCICardIdentifier c
  handleHttpErrors = handle @HttpException (Left > return) 
  -- handle $ (\(e ::HttpException) -> Left e) 











{- | Values (`Src`s and `Dst`s) which this program can work with.

-}

data Value (a :: *) where

  -- “values”:

  HaskellValue    :: (Binary a) => a -> Value a

  JavaScriptValue :: JSON.Value     -> Value JSON.Value

  -- “paths”:

  RemotePath      :: URI            -> Value URI

  ArchivedPath    :: FilePath       -> Value FilePath
  CompressedPath  :: FilePath       -> Value FilePath

  -- “strings”:

  String          :: String         -> Value String

  LazyText        :: LazyText       -> Value LazyText
  StrictText      :: StrictText     -> Value StrictText

  LazyBytes       :: LazyBytes      -> Value LazyBytes
  StrictBytes     :: StrictBytes    -> Value StrictBytes
  CompressedBytes :: StrictBytes    -> Value StrictBytes







============================================================




export xxx_package_xxx="dictation-vocabulary"
export xxx_program_xxx="haskell-vocabulary"
export Xxx_Module_xxX="Language.Haskell.Dictation.Vocabulary"
export __Synopsis__="Parse Haskell files for dictation vocabulary"
export __Categories__="Dictation"
export __GithubUser__="sboosali"
export __GithubRepository__="configuration"
export xxx_package_subdir_xxx="dictation/src"
export __Project__="configuration"
export __ProjectDirectory__="~/configuration/dictation/src/"
export __Name__="Sam Boosalis"
export __Email__="samboosalis@gmail.com"






#!/bin/bash
set -e
set -u

##################################################

INPUT=./xxx-package-xxx.cabal
OUTPUT=./dictation-vocabulary.cabal
CONFIG=./skeletor.ini

##################################################

function _skeletor_for-dictation-vocabulary
(

echo ========================================
echo

echo "${INPUT}"
echo "${OUTPUT}"
echo "${CONFIG}"

echo
echo ========================================
echo


# shellcheck source=./skeletor.ini
source "${CONFIG}"

echo "xxx-package-xxx        = ${xxx_package_xxx}"
echo "xxx-program-xxx        = ${xxx_program_xxx}"
echo "Xxx_Module_xxX         = ${Xxx_Module_xxX}"
echo "__Synopsis__           = ${__Synopsis__}"
echo "__Categories__         = ${__Categories__}"
echo "__GithubUser__         = ${__GithubUser__}"
echo "__GithubRepository__   = ${__GithubRepository__}"
echo "xxx-package-subdir-xxx = ${xxx_package_subdir_xxx}"
echo "__Project__            = ${__Project__}"
echo "__ProjectDirectory__   = ${__ProjectDirectory__}"
echo "__Name__               = ${__Name__}"

echo
echo ========================================
echo

SUBSTITUTIONS=( )
SUBSTITUTIONS+=( "s/xxx-package-xxx/${xxx_package_xxx}/g" )
SUBSTITUTIONS+=( "s/xxx-program-xxx/${xxx_program_xxx}/g" )
SUBSTITUTIONS+=( "s/Xxx_Module_xxX/${Xxx_Module_xxX}/g" )
SUBSTITUTIONS+=( "s:__Categories__:${__Categories__}:g" )
SUBSTITUTIONS+=( "s/__GithubUser__/${__GithubUser__}/g" )
SUBSTITUTIONS+=( "s/__GithubRepository__/${__GithubRepository__}/g" )
SUBSTITUTIONS+=( "s:xxx-package-subdir-xxx:${xxx_package_subdir_xxx}:g" )
SUBSTITUTIONS+=( "s:__Project__:${__Project__}:g" )
SUBSTITUTIONS+=( "s:__ProjectDirectory__:${__ProjectDirectory__}:g" )

SUBSTITUTIONS+=( "s/__Name__/${__Name__}/g" )
SUBSTITUTIONS+=( "s:__Synopsis__:${__Synopsis__}:g" )

for SUBSTITUTION in "${SUBSTITUTIONS[@]}"
do
  printf "%s\n" "$SUBSTITUTION"
done

echo
echo ========================================
echo

for SUBSTITUTION in "${SUBSTITUTIONS[@]}"; do printf " -e '%s' " "$SUBSTITUTION"; done

echo

#sed $(for SUBSTITUTION in "${SUBSTITUTIONS[@]}"; do printf " -e '%s' " "$SUBSTITUTION"; done) "${INPUT}"

sed  -e 's/xxx-package-xxx/dictation-vocabulary/g'  -e 's/xxx-program-xxx/haskell-vocabulary/g'  -e 's/Xxx_Module_xxX/Language.Haskell.Dictation.Vocabulary/g'  -e 's:__Categories__:Dictation:g'  -e 's/__GithubUser__/sboosali/g'  -e 's/__GithubRepository__/configuration/g'  -e 's:xxx-package-subdir-xxx:dictation/src:g'  -e 's:__Project__:configuration:g'  -e 's:__ProjectDirectory__:~/configuration/dictation/src/:g'  -e 's/__Name__/Sam Boosalis/g'  -e 's:__Synopsis__:Parse Haskell files for dictation vocabulary:g'  "${INPUT}"  >   "${OUTPUT}"

echo
echo ========================================

)

##################################################

_skeletor_for-dictation-vocabulary




============================================================


#!/usr/bin/env cabal

{- cabal:

  build-depends: base         ^>= 4.12
               , bytestring   ^>= 0.10
               , conduit      ^>= 1.3
               , http-conduit ^>= 2.3
               , resourcet    ^>= 1.2

-}

--------------------------------------------------
--- Extensions -----------------------------------
--------------------------------------------------

{-# LANGUAGE OverloadedStrings     #-}
{-# LANGUAGE PackageImports        #-}

--------------------------------------------------

{- | Example for the @http-conduit@ package.

See:

* <http://hackage.haskell.org/package/http-conduit/docs/Network.HTTP.Simple.html Network.HTTP.Simple>

-}

module Main where

--------------------------------------------------
--- Imports --------------------------------------
--------------------------------------------------

import qualified "http-conduit" Network.HTTP.Simple as HTTP
import           "http-conduit" Network.HTTP.Simple ( )

--------------------------------------------------

import qualified "conduit" Conduit as Conduit
import           "conduit" Conduit ( ConduitM )

import qualified "resourcet" Control.Monad.Trans.Resource as Resource
import           "resourcet" Control.Monad.Trans.Resource ( ResourceT )

--------------------------------------------------
--- Imports --------------------------------------
--------------------------------------------------

import qualified "bytestring" Data.ByteString as Bytes
import           "bytestring" Data.ByteString ( ByteString )

--------------------------------------------------

import qualified "base" System.IO as IO

import            "base" Data.Function ( (&) )
import            "base" Data.Void     ( Void )

--------------------------------------------------

import "base" Prelude

--------------------------------------------------
--- Main -----------------------------------------
--------------------------------------------------

main :: IO ()
main = do

  download (Just "GET") "https://mtgjson.com/json/Vintage.json.gz" "/tmp/Vintage.json.gz"

--------------------------------------------------
-- Functions -------------------------------------
--------------------------------------------------

{- | Download a file.

@download method uri fp@ downloads URI @uri@ to FilePath @fp@ (with optional request method @method@).

The file contents being downloaded may be larger than available memory. @uri@ is streamed into @fp@.

== Examples

@
>> download (Just "GET") "https://mtgjson.com/json/Vintage.json.gz" "/tmp/Vintage.json.gz"
@

-}

download :: Maybe String -> String -> FilePath -> IO ()
download method uri fp = do

  let method' = method & maybe "GET" id & (++ " ")
  let uri'    = method' <> uri

  request <- HTTP.parseRequest uri'

  Resource.runResourceT (HTTP.httpSink request consume)

  where

  consume :: HTTP.Response () -> ConduitM ByteString Void (ResourceT IO) ()
  consume response = do

    Conduit.sinkFileCautious fp

--------------------------------------------------
-- Notes -----------------------------------------
--------------------------------------------------

-- type Sink i = ConduitM i Void

-- sinkFile :: MonadResource m => FilePath -> ConduitT ByteString o m ()
-- sinkFile :: FilePath -> ConduitT ByteString o IO ()
-- sinkFile :: FilePath -> ConduitT ByteString Void IO ()
-- sinkFile :: FilePath -> Sink ByteString IO ()

-- httpSink :: MonadUnliftIO m => Request -> (Response () -> ConduitM ByteString Void m a) -> m a

-- runResourceT :: MonadUnliftIO m => ResourceT m a -> m a

--------------------------------------------------
-- EOF -------------------------------------------
--------------------------------------------------



============================================================

--------------------------------------------------
--------------------------------------------------

{- | `Src`s to read.

-}

data Source

  = SourceStdin
  | SourceFilePath    FilePath
  | SourceStrictBytes StrictBytes
  | SourceLazyBytes   LazyBytes

  deriving stock    (Show,Read,Eq,Ord)
  deriving stock    (Lift,Data,Generic)
  deriving anyclass (NFData,Hashable)

--------------------------------------------------
--------------------------------------------------

{- | Values (`Src`s) which this program knows how to /read/.

-}

data ReadValue (a :: *) where

  -- “values”:

  HaskellValue    :: (Binary a)
                  => LazyBytes
                  -> ReadValue a

  JSONValue       :: (FromJSON a)
                  => JSON.Value
                  -> ReadValue a

  -- “paths”:

  RemotePath      :: URI            -> ReadValue LazyBytes

  ArchivedPath    :: FilePath       -> ReadValue LazyBytes
  CompressedPath  :: FilePath       -> ReadValue LazyBytes

  -- “strings”:

  String          :: String         -> ReadValue String

  LazyText        :: LazyText       -> ReadValue LazyText
  StrictText      :: StrictText     -> ReadValue StrictText

  LazyBytes       :: LazyBytes      -> ReadValue LazyBytes
  StrictBytes     :: StrictBytes    -> ReadValue StrictBytes
  CompressedBytes :: StrictBytes    -> ReadValue StrictBytes

--------------------------------------------------
--------------------------------------------------

{- | Values (`Dst`s) which this program knows how to /write/.

-}

data WriteValue (a :: *) where







--------------------------------------------------

readSource :: Source -> IO LazyBytes
readSource = \case

  SourceStdin          -> Lazy.getContents
  SourceFilePath    fp -> Lazy.readFile fp
  SourceStrictBytes bs -> return (Lazy.fromChunks [bs])
  SourceLazyBytes   bs -> return bs

--------------------------------------------------

readValue :: ReadValue a -> IO a
readValue = \case

  HaskellValue b    -> return "TODO"
  JSONValue    v    -> return "TODO"

  RemotePath uri    -> return "TODO"

  ArchivedPath   fp -> return "TODO"
  CompressedPath fp -> return "TODO"

  String     s      -> return s
  LazyText   t      -> return t
  StrictText t      -> return t

  LazyBytes       b -> return b
  StrictBytes     b -> return b
  CompressedBytes b -> return "TODO"


============================================================

  let method' = method & maybe "GET" id & (++ " ")


  let mtg_hs = mtgjson2mtghs mtg_json


  ------------------------------

  promptSrc :: IO (MTGJSON String)
  promptSrc = MTGJSON <$> do

    IO.hGetContents IO.stdin

    -- IO.hGetContents IO.stdin

  ------------------------------

  readSrc :: FilePath -> IO (MTGJSON String)
  readSrc fp = MTGJSON <$> do

    IO.readFile fp

  ------------------------------

  fetchSrc :: URI -> IO (MTGJSON String)
  fetchSrc uri = fetch (FetchMtgJsonGz uri)









IO.hSetBinaryMode IO.stdin True >> Lazy.hGetContents IO.stdin











  SrcUri uriSrc -> download Nothing uriSrc >>= (\fpSrc -> Directory.copyFile fpSrc fpDst)




















--------------------------------------------------
-- Utilities -------------------------------------
--------------------------------------------------

{- | an application-specific filepath to a temporary file.

e.g.:

@
> newTemporaryFilePath "project.tar.gz"
"/tmp/haskell-skeletor/2019-04-06-21h-43m-51s-852ms_project.tar.gz"
@

-}

newTemporaryFilePath :: String -> IO FilePath
newTemporaryFilePath name = do

  directory <- Directory.getTemporaryDirectory
  time      <- Time.getZonedTime

  let timestamp = formatZonedTimeAsFilePath time

  let dirname  = directory </> programExecutable
  let basename = timestamp <> "_" <> name 

  let path = dirname </> basename

  return path

--------------------------------------------------

{- | Format a timestamp to be part of a filepath.

e.g.:

@
> formatZonedTimeAsFilePath _
"2019-04-06-21h-43m-51s-852ms"
@

-}

formatZonedTimeAsFilePath :: Time.ZonedTime -> String
formatZonedTimeAsFilePath t =

  Time.formatTime locale timeFormatWithHyphensAndUnits t

  where

  locale = Time.defaultTimeLocale
  -- NOTE even « Prelude.undefined » works as the locale for « ZonedTime » (it's ignored).

--------------------------------------------------

timeFormatWithHyphensAndUnits :: String
timeFormatWithHyphensAndUnits = "%Y-%m-%d-%Hh-%Mm-%Ss-%03qms"

-- NOTE given the meta-syntax « %<modifier><width><alternate><specifier> »,
--      the syntax « %03q » means (0-padded) 3-width picoseconds (i.e. milliseconds).


















    timestamp <- _
    tmp <- Directory.getTemporaryDirectory

    let dir = tmp </> "mtg-json"
    let fp = dir </> ""

    mkdir_p dir
    download Nothing uri fp
    Lazy.readFile fp











































































































































































==============================================