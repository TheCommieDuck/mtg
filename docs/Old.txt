==============================================




{-

  format "CREATE TYPE %s AS ENUM ( %s );" name labels

   [ "CREATE TYPE"
  , docLabels 
  , "AS ENUM"
  , " ("
  , docLabels 
  , " );"
  ]

  go
    = PP.align
    . PP.sep
    . List.zipWith (<+>) (List.repeat ", ")

type SQLDoc = PP.Doc SQLAnnotation

data SQLAnnotation

  = SQLKeyword 
  | SQLString 
  | SQLComment 
  | SQLEnumName 
  | SQLEnumLabel 

PP.ANSI.bold
PP.ANSI.italicized
PP.ANSI.underlined

PP.ANSI.colorDull

-- The 8 ANSI terminal colors:

enum Color

Black	 
Red	 
Green	 
Yellow	 
Blue	 
Magenta	 
Cyan	 
White	 




-}



==============================================

annotateKeyword :: String -> SQLDoc
annotateKeyword s = PP.annotate (Just SQLKeyword) (PP.pretty s)

annotateString :: String -> SQLDoc
annotateString s = PP.annotate (Just SQLString) (PP.pretty s)

annotateType :: String -> SQLDoc
annotateType s = PP.annotate (Just SQLType) (PP.pretty s)

annotateComment :: String -> SQLDoc
annotateComment s = PP.annotate (Just SQLComment) (PP.pretty s)

annotateLiteral :: String -> SQLDoc
annotateLiteral s = PP.annotate (Just SQLLiteral) (PP.pretty s)


>>> sql_CREATE_rgb = sql_CREATE_TYPE_AS_ENUM SQLCreateEnum{ enumName = "rgb", enumLabels = [ "r", "g", "b" ] }
>>> sql_CREATE_rgb
CREATE TYPE rgb AS ENUM ('r', 'g', 'b');


PP.SimpleDocStream

(Just PP.defaultLayoutOptions{ = })



>>> sql_CREATE_color layout = sql_CREATE_TYPE_AS_ENUM layout SQLCreateEnum{ enumName = "color", enumLabels = [ "white", "blue", "black", "red", "green" ] }
>>> Prelude.putStrLn (sql_CREATE_color Nothing)
CREATE TYPE color AS ENUM ('white', 'blue', 'black', 'red', 'green');
>>> Prelude.putStrLn (sql_CREATE_color (Just PP.LayoutOptions { PP.layoutPageWidth = PP.AvailablePerLine 30 1.0 }))
CREATE TYPE color AS ENUM ( 'white',
                            'blue',
                            'black',
                            'red',
                            'green' );






extensions = 

    "AutoDeriveTypeable\ 
     BangPatterns\ 
     CPP\ 
     ConstraintKinds\ 
     DataKinds\ 
     DefaultSignatures\ 
     DeriveAnyClass\ 
     DeriveAnyClass\ 
     DeriveDataTypeable\ 
     DeriveDataTypeable\ 
     DeriveFoldable\ 
     DeriveFunctor\ 
     DeriveGeneric\ 
     DeriveGeneric\ 
     DeriveLift\ 
     DeriveTraversable\ 
     DerivingStrategies\
     DerivingStrategies\ 
     DoAndIfThenElse\ 
     DuplicateRecordFields\ 
     EmptyCase\ 
     EmptyDataDecls\ 
     ExplicitNamespaces\ 
     FlexibleContexts\ 
     FlexibleContexts\ 
     FlexibleInstances\ 
     FlexibleInstances\ 
     FunctionalDependencies\ 
     GADTs\ 
     GeneralizedNewtypeDeriving\ 
     InstanceSigs\ 
     KindSignatures\ 
     KindSignatures\ 
     LambdaCase\ 
     LambdaCase\ 
     MultiParamTypeClasses\ 
     MultiWayIf\ 
     NamedFieldPuns\ 
     NoImplicitPrelude\ 
     NoImplicitPrelude\ 
     PackageImports\ 
     PackageImports\ 
     PatternSynonyms\ 
     PostfixOperators\ 
     RankNTypes\ 
     RecordWildCards\ 
     ScopedTypeVariables \ 
     ScopedTypeVariables\ 
     StandaloneDeriving\ 
     TupleSections\ 
     TupleSections\ 
     TypeFamilies\ 
     TypeFamilies\ 
     TypeOperators\ 
     TypeOperators\ 
     UndecidableInstances\ 
     ViewPatterns"











--------------------------------------------------

extensions2flags :: [String] -> [String]
extensions2flags = fmap go . filterBlanks
  where

  go s = if (not (null s)) then ("-X" ++ s) else










>>> sql_CREATE_color layout = sql_CREATE_TYPE_AS_ENUM layout SQLCreateEnum{ enumName = "color", enumLabels = [ "white", "blue", "black", "red", "green" ] }
>>> Prelude.putStrLn (sql_CREATE_color Nothing)
CREATE TYPE color AS ENUM ( 'white', 'blue', 'black', 'red', 'green' );
>>> Prelude.putStrLn (sql_CREATE_color (Just PP.LayoutOptions { PP.layoutPageWidth = PP.AvailablePerLine 30 1.0 }))
CREATE TYPE color AS ENUM ( 'white',
                            'blue',
                            'black',
                            'red',
                            'green' );









data CardObject = CardObject 
 
  { _id            :: Text 
  , _layout        :: Text 
  , _name          :: Text 
  , _names         :: Maybe [Text] 
  , _manaCost      :: Maybe Text 
  , _cmc           :: Natural 
  , _colors        :: Maybe [Text] 
  , _colorIdentity :: Maybe [Text] 
  , _type          :: Text 
  , _supertypes    :: Maybe [Text] 
  , _types         :: Maybe [Text] -- ^ Un-cards can have no type 
  , _subtypes      :: Maybe [Text] 
  , _rarity        :: Text 
  , _text          :: Maybe Text 
  , _flavor        :: Maybe Text 
  , _artist        :: Text
  , _number        :: Maybe Text
  , _power         :: Maybe Text -- ^ Un-cards can have non-integer power/toughness 
  , _toughness     :: Maybe Text  
  , _loyalty       :: Maybe Natural 
  , _multiverseid  :: Maybe Natural
  , _variations    :: Maybe [Natural] 
  , _imageName     :: Maybe Text 
  , _watermark     :: Maybe Text 
  , _border        :: Maybe Text 
  , _timeshifted   :: Maybe Bool -- IsCardTimeShifted
  , _hand          :: Maybe Integer  -- ^ Vanguard only 
  , _life          :: Maybe Integer -- ^ Vanguard only 
  , _reserved      :: Maybe Bool -- IsCardReserved 
  , _releaseDate   :: Maybe Text -- ^ Promo only 
  , _starter       :: Maybe Bool -- IsCardStarter 
  , _mciNumber     :: Maybe Text  -- ^ used by `MagicCards.info`, almost always identical to '_CardObject_number' 
  , _rulings       :: Maybe [CardRulingObject] 
  , _foreignNames  :: Maybe [CardForeignPrintingObject] 
  , _printings     :: [Text]  
  , _originalText  :: Maybe Text 
  , _originalType  :: Maybe Text
  , _legalities    :: Maybe [CardFormatLegalityObject]
  , _source        :: Maybe Text 

  }















  , _artist                 :: -- ^ e.g. @"..."@
  , _borderColor            :: -- ^ e.g. @"black"@
  , _colorIdentity          :: -- ^ e.g. @[ ... ]@
  , _colors                 :: -- ^ e.g. @[ ... ]@
  , _convertedManaCost      :: -- ^ e.g. @0@
  , _foreignData            :: -- ^ e.g. @[ ... ]@
  , _frameVersion           :: -- ^ e.g. @YYYY@
  , _hasFoil                :: -- ^ e.g. @"false"@
  , _hasNonFoil             :: -- ^ e.g. @"true"@
  , _isReserved             :: -- ^ e.g. @"true"@
  , _layout                 :: -- ^ e.g. @"normal"@
  , _legalities             :: -- ^ e.g. @{ "vintage": "restricted", "legacy": "banned", "standard": "legal", ... }@
  , _manaCost               :: -- ^ e.g. @"{B}{B/2}{B/P}"@
  , _multiverseId           :: -- ^ e.g. @390@
  , _name                   :: -- ^ e.g. @"Phyrexian Goblin"@
  , _number                 :: -- ^ e.g. @"51a"@ (@Delver of Secrets@, being a /Double-Faced Card/, has an alphanumeric @collectersNumber@; @Insectile Aberration@'s is @"51b"@).
  , _originalText           :: -- ^ e.g. @"..."@
  , _originalType           :: -- ^ e.g. @"Summon Legend"@
  , _printings              :: -- ^ e.g. @[ "LEA", "LEB" ]@
  , _rarity                 :: -- ^ e.g. @"common"@
  , _rulings                :: -- ^ e.g. @[ ... ]@
  , _scryfallId             :: -- ^ e.g. @"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"@
  , _scryfallIllustrationId :: -- ^ e.g. @"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"@
  , _scryfallOracleId       :: -- ^ e.g. @"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"@
  , _subtypes               :: -- ^ e.g. @[ "Goblin", "Wizard" ]@
  , _supertypes             :: -- ^ e.g. @[ "Legendary", "Snow" ]@
  , _text                   :: -- ^ e.g. @"..."@
  , _type                   :: -- ^ e.g. @"Legendary Snow Artifact Creature — Goblin Construct"@
  , _types                  :: -- ^ e.g. @[ "Artifact", "Creature" ]@
  , _uuid                   :: -- ^ e.g. @"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"@
  , _uuidV421               :: -- ^ e.g. @"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"@
  }





















instance IsList Colors where
  type Item Colors = String
  fromList = coerce . fmap T.pack
  toList   = fmap T.unpack . coerce














--------------------------------------------------
-- Pretty ----------------------------------------
--------------------------------------------------

instance Pretty UUID where

  pretty = prettyUUID





















flags :: [String]
flags = concat

  [ [ ":set -package mtg-types" ]
  , extensions2flags extensions
  , options
  ]



















newtype ManaCost = ManaCost Text
 
  deriving stock    (Show,Read)
  deriving stock    (Lift,Data,Generic)

  deriving newtype  (Eq,Ord,Semigroup,Monoid)
  deriving newtype  (IsString)
  deriving newtype  (NFData,Hashable)













-- | @≡ "Colorless"@

pattern Colorless :: Color
pattern Colorless = "Colorless"

colorless :: Color
colorless = "Colorless"


abbreviateColor :: Color -> Maybe Text
abbreviateColor (Color s0) = Text.toUpper <$> (go s1)
  where

  s1 = Text.toLower s0

  go = \case

    "white"     -> Just "W"
    "blue"      -> Just "U"
    "black"     -> Just "B"
    "red"       -> Just "R"
    "green"     -> Just "G"
    "colorless" -> Just "C"

    "w"         -> Just "W"
    "u"         -> Just "U"
    "b"         -> Just "B"
    "r"         -> Just "R"
    "g"         -> Just "G"
    "c"         -> Just "C"

    _           -> Nothing









module MTG.Types.Parse

  ( module MTG.Types.Parse

  , Parsing(..)
  , CharParsing(..)
  ) where



==============================================


--------------------------------------------------
-- Constants -------------------------------------
--------------------------------------------------

white :: Color
white = "White"

blue :: Color
blue = "Blue"

black :: Color
black = "Black"

red :: Color
red = "Red"

green :: Color
green = "Green"







>>> parse "U" == Blue
True
>>> parse "blue" == Blue
True





pAssoc :: (CharParsing m) => Assoc a -> m a
pAssoc kvs = asum (pPair <$> kvs)
  where

  pPair (k,v) = P. _











-- | Association List.

type Assoc a = [( Text, a )]








pColor :: CharParsing m => m Color
pColor = do

  pAssoc cs

  where

  cs :: Assoc Color
  cs = csLower <> csUpper

  csLower = csUpper & bimap Text.toLower id

  csUpper =

    [ "W" -: White
    , "U" -: Blue
    , "B" -: Black
    , "R" -: Red
    , "G" -: Green

    , "White" -: White
    , "Blue"  -: Blue
    , "Black" -: Black
    , "Red"   -: Red
    , "Green" -: Green
    ]









data Annotation

  = AnnOracleText
  | AnnReminderText
  | AnnFlavorText

  | AnnWhite
  | AnnBlue
  | AnnBlack
  | AnnRed
  | AnnGreen
  | AnnColorless

  | AnnKeyword
  | AnnPerson
  | AnnNamesake

  | AnnUnicode Char
















{-| Pretty-Print an @Enum@ via an /association list/.

-}

ppAssoc
  :: Assoc a
  -> (a -> Maybe (Doc i))

ppAssoc kvs = \x ->

  let
    doc' = Map.lookup v kvs'
    doc  = PP.pretty <$> doc'
  in
    doc

  where

  ppKVs = _

  kvs' :: Map a Text
  kvs' = kvs & 

  (foldr (<|>) empty) pKvs

{-# INLINEABLE ppAssoc #-}













runParser :: forall a. (forall m. (MTGParsing m) => m a) -> (String -> [a])
runParser p = go
  where

  go :: String -> [a]
  go = Read.readP_to_S p > fmap fst

















runParser :: (MonadThrow m) => forall a. (forall m. (MTGParsing p) => p a) -> (String -> m a)
runParser p = go
  where

  go :: String -> m a
  go =

    let
      p' :: ReadP a
      p' = p
    in
      Read.readP_to_S p' > fmap fst > throwListM

-- readP_to_S :: ReadP a -> ReadS a
-- readP_to_S :: ReadP a -> String -> [(a,String)]















data ParseError = ParseError

  { getParseErrors :: [String]
  }













renderText :: PP.SimpleDocStream i -> Text
renderText = PP.layoutSmart PP.defaultLayoutOptions > PP.Text.renderStrict











>>> "prefix" <+> align (vsep ["text", "to", "lay", "out"])
prefix text
       to
       lay
       out







data ParseError = ParseError

  { getParseErrors :: [MTGDocument]
  }

  deriving stock    (Generic)
  deriving stock    (Eq,Ord)
  deriving anyclass (Semigroup,Monoid)
  deriving anyclass (NFData,Hashable)











{-| 

== Signatures

@
'ParseError' :: ['MTGDocument'] -> 'ParseError'
'parseError' :: String   ->   'SomeException'
@

-}

parseError :: String -> SomeException
parseError

  = pretty
  > (: [])
  > ParseError
  > toException












--------------------------------------------------

{-| Multiple errors

== Signatures

@
'ParseError' :: ['MTGDocument'] -> 'ParseError'
'parseErrors' :: [String]     -> 'ParseError'
@

-}

parseErrors :: [String] -> ParseError
parseErrors

  = fmap pretty
  > ParseError










runParser
  :: forall m a.
     ( MonadThrow m
     )
  => String -> (forall p. (MTGParsing p) => p a)
  -> (String -> m a)

runParser e p = go
  where

  go :: String -> m a
  go =

    let
      p' :: ReadP a
      p' = p
    in
      Read.readP_to_S p' > fmap fst > throwListM (parseError e)







{- | 

@
instance 'IsString' XYZ where
  fromString = 'fromString_MonadThrow' parseXYZ
@

-}

fromString_MonadThrow
  :: forall a.
     (forall m. (MonadThrow m) => String -> m a)
  -> (String -> a)
fromString_MonadThrow pM = pI
  where

  pI = pM










import           "base" GHC.Stack.Types (HasCallStack)
import           "base" GHC.Stack       (CallStack,callStack,prettyCallStack)--,getCallStack










instance ( HasCallStack ) => IsString Color where










pManaSymbol :: (MTGParsing m) => m ManaSymbol
pManaSymbol = P.braces (pAbbreviatedManaSymbol `P.sepBy1` P.spaces)

--------------------------------------------------

pAbbreviatedManaSymbol :: (MTGParsing m) => m ManaSymbol
pAbbreviatedManaSymbol = _










prettyManaSymbol :: ManaSymbol -> String
prettyManaSymbol (ManaSymbol cs) = ppManaSymbol > runPrinter










pManaSymbol :: (MTGParsing m) => m ManaSymbol
pManaSymbol = toManaSymbol (P.braces pAbbreviatedManaSymbol) `P.sepBy1` P.spaces









pManaSymbol :: (MTGParsing m) => m ManaSymbol
pManaSymbol = pAbbreviatedManaSymbol -- TODO pKnown pUnknown

--------------------------------------------------

pAbbreviatedManaSymbol :: (MTGParsing m) => m ManaSymbol
pAbbreviatedManaSymbol = ManaSymbol <$> P.braces p
  where

  p = empty









abbreviateManaSymbol :: ManaSymbol -> Maybe Text
abbreviateManaSymbol (ManaSymbol s0) = Text.toUpper <$> (go s1)
  where

  s1 = Text.toLower s0

  go = \case

    "white"     -> Just "W"
    "blue"      -> Just "U"
    "black"     -> Just "B"
    "red"       -> Just "R"
    "green"     -> Just "G"

    "w"         -> Just "W"
    "u"         -> Just "U"
    "b"         -> Just "B"
    "r"         -> Just "R"
    "g"         -> Just "G"

    _           -> Nothing









abbreviationsManaSymbol :: Assoc ManaSymbol
abbreviationsManaSymbol =

    [ "W" -: WhiteManaSymbol
    , "U" -: BlueManaSymbol
    , "B" -: BlackManaSymbol
    , "R" -: RedManaSymbol
    , "G" -: GreenManaSymbol
    ]








abbreviatedManaSymbols :: Assoc ManaSymbol
abbreviatedManaSymbols =

    [ "W" -: WhiteManaSymbol
    , "U" -: BlueManaSymbol
    , "B" -: BlackManaSymbol
    , "R" -: RedManaSymbol
    , "G" -: GreenManaSymbol
    ]








------------------

phyrexian :: ManaSymbol -> ManaSymbol
phyrexian (ManaSymbol s) = ManaSymbol ("{P" <> s <> "}")

--------------------------------------------------

monohybrid :: ManaSymbol -> ManaSymbol
monohybrid (ManaSymbol s) = ManaSymbol ("{2/" <> s <> "}")








type Colors = [Color]
















whichColors :: [Color] -> Colors
whichColors = _










  e :: PatternMatchFail
  e = PatternMatchFail (format "toColors: {{{ toColors " % Format.string % " }}} " (show cs))













toColorsM :: (MonadThrow m) => [Color] -> m Colors
toColorsM cs = cs & (ordNub > sort > go)
  where

  go = \case

      []                                 -> return (ZeroColors                          )
      [a]                                -> return (OneColor                    a       )
      [a,b]                              -> return (TwoColors   (toGuild        a b)    )
      [a,b,c]                            -> return (ThreeColors (toShardOrWedge a b c)  )
      [a,b,c,d]                          -> return (FourColors  (toNephilim     a b c d))
      [ White, Blue, Black, Red, Green ] -> return (FiveColors                          )
      _                                  -> throwM e -- (NOTE: this case should never be reached.)

  e :: PatternMatchFail
  e = PatternMatchFail (runFormat ("``` " % Format.string % " ```: {{{ toColors " % Format.string % " }}} ")
                        (displayName 'toColors)
                        (showsPrec applicationPrecedence cs "")
                       )





















toGuild :: (MonadThrow m) => Color -> Color -> m Guild

toGuild White Blue  = return Azorius  
toGuild Blue  White = return Azorius  

toGuild Blue  Black = return Dimir    
toGuild Black Blue  = return Dimir    

toGuild Black Red   = return Rakdos   
toGuild Red   Black = return Rakdos   

toGuild Red   Green = return Gruul    
toGuild Green Red   = return Gruul    

toGuild Green White = return Selesnya 
toGuild White Green = return Selesnya 

toGuild White Black = return Orzhov
toGuild Black White = return Orzhov

toGuild Black Green = return Golgari  
toGuild Green Black = return Golgari  

toGuild Green Blue  = return Simic    
toGuild Blue  Green = return Simic    

toGuild Blue  Red   = return Izzet    
toGuild Red   Blue  = return Izzet    

toGuild Red   White = return Boros    
toGuild White Red   = return Boros

toGuild White White = throwM e
toGuild Blue  Blue  = throwM e
toGuild Black Black = throwM e
toGuild Red   Red   = throwM e
toGuild Green Green = throwM e































































==============================================